import { logError, logWarn, logInfo } from "@/lib/logger-client";
// src/app/book/utils/error-handling.ts
// Ù†Ø¸Ø§Ù… Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø°ÙƒÙŠ Ù…Ø¹ retry logic

import React from 'react'
import { BookingFormData } from '../types/booking-form.types'
import { Service } from '../types/booking-form.types'

// Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù…Ø®ØªÙ„ÙØ©
export enum ErrorType {
  NETWORK_ERROR = 'network_error',
  VALIDATION_ERROR = 'validation_error',
  SERVER_ERROR = 'server_error',
  TIMEOUT_ERROR = 'timeout_error',
  BOOKING_CONFLICT = 'booking_conflict',
  RATE_LIMIT = 'rate_limit',
  UNKNOWN_ERROR = 'unknown_error'
}

// ÙˆØ§Ø¬Ù‡Ø© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø®Ø·Ø£
export interface ErrorInfo {
  type: ErrorType
  message: string
  arabicMessage: string
  canRetry: boolean
  retryAfter?: number
  suggestedAction?: string
  technicalDetails?: any
}

// ÙˆØ§Ø¬Ù‡Ø© Ø³ÙŠØ§Ù‚ Ø§Ù„Ø®Ø·Ø£
export interface ErrorContext {
  formData?: BookingFormData
  services?: Service[]
  networkQuality?: 'fast' | 'slow' | 'offline'
  retryCount?: number
  timestamp?: number
  userAgent?: string
  url?: string
  stackTrace?: string
}

// Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
export function handleBookingError(error: any, _context?: ErrorContext): ErrorInfo {
  const errorInfo = analyzeError(error)

  // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø·Ø£ Ù„Ù„Ù…Ø·ÙˆØ±ÙŠÙ†
  logBookingError(error, _context)

  return errorInfo
}

// ØªØ­Ù„ÙŠÙ„ Ù†ÙˆØ¹ Ø§Ù„Ø®Ø·Ø£
function analyzeError(error: any): ErrorInfo {
  // Network errors - Ø¥ØµÙ„Ø§Ø­ navigator Ù„Ù„Ù€ SSR
  const isOffline = typeof navigator !== 'undefined' ? !navigator.onLine : false

  if (isOffline || error.name === 'TypeError' && error.message.includes('fetch')) {
    return {
      type: ErrorType.NETWORK_ERROR,
      message: 'Network connection failed',
      arabicMessage: 'Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª. ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØªØµØ§Ù„ ÙˆØ­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰',
      canRetry: true,
      suggestedAction: 'ØªØ­Ù‚Ù‚ Ù…Ù† Ø§ØªØµØ§Ù„ Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª'
    }
  }

  // Timeout errors
  if (error.name === 'AbortError' || error.message?.includes('timeout')) {
    return {
      type: ErrorType.TIMEOUT_ERROR,
      message: 'Request timeout',
      arabicMessage: 'Ø§Ù†ØªÙ‡Øª Ù…Ù‡Ù„Ø© Ø§Ù„Ø§ØªØµØ§Ù„. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰',
      canRetry: true,
      retryAfter: 3000,
      suggestedAction: 'Ø§Ù†ØªØ¸Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ø«Ù… Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰'
    }
  }

  // HTTP status codes
  const statusCode = error.status || (error.message?.match(/\d{3}/) ? parseInt(error.message.match(/\d{3}/)[0]) : null)

  if (statusCode) {
    switch (statusCode) {
      case 400:
        return {
          type: ErrorType.VALIDATION_ERROR,
          message: 'Invalid request data',
          arabicMessage: 'Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø©. ÙŠØ±Ø¬Ù‰ Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø¯Ø®Ù„Ø©',
          canRetry: false,
          suggestedAction: 'Ø±Ø§Ø¬Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¯Ø®Ù„Ø©'
        }

      case 409:
        return {
          type: ErrorType.BOOKING_CONFLICT,
          message: 'Booking conflict',
          arabicMessage: 'Ù‡Ø°Ø§ Ø§Ù„Ù…ÙˆØ¹Ø¯ Ù…Ø­Ø¬ÙˆØ² Ø¨Ø§Ù„ÙØ¹Ù„. ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ù…ÙˆØ¹Ø¯ Ø¢Ø®Ø±',
          canRetry: false,
          suggestedAction: 'Ø§Ø®ØªØ± Ù…ÙˆØ¹Ø¯ Ø¢Ø®Ø±'
        }

      case 429:
        return {
          type: ErrorType.RATE_LIMIT,
          message: 'Too many requests',
          arabicMessage: 'Ø¹Ø¯Ø¯ ÙƒØ¨ÙŠØ± Ù…Ù† Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª. Ø§Ù†ØªØ¸Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ø«Ù… Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰',
          canRetry: true,
          retryAfter: 60000,
          suggestedAction: 'Ø§Ù†ØªØ¸Ø± Ø¯Ù‚ÙŠÙ‚Ø© ÙˆØ§Ø­Ø¯Ø©'
        }

      case 500:
      case 502:
      case 503:
        return {
          type: ErrorType.SERVER_ERROR,
          message: 'Server error',
          arabicMessage: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹ Ø£Ùˆ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§',
          canRetry: true,
          retryAfter: 5000,
          suggestedAction: 'Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø£Ùˆ ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§'
        }

      default:
        return {
          type: ErrorType.UNKNOWN_ERROR,
          message: `HTTP ${statusCode}`,
          arabicMessage: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰',
          canRetry: true,
          suggestedAction: 'Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰'
        }
    }
  }

  // JavaScript errors
  if (error instanceof TypeError) {
    return {
      type: ErrorType.VALIDATION_ERROR,
      message: 'Data validation error',
      arabicMessage: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª',
      canRetry: false,
      suggestedAction: 'ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¯Ø®Ù„Ø©'
    }
  }

  // Default unknown error
  return {
    type: ErrorType.UNKNOWN_ERROR,
    message: error.message || 'Unknown error',
    arabicMessage: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰',
    canRetry: true,
    suggestedAction: 'Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰'
  }
}

// ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
export function logBookingError(error: any, _context?: ErrorContext) {
  const errorLog = {
    timestamp: new Date().toISOString(),
    error: {
      name: error.name,
      message: error.message,
      stack: error.stack
    },
    _context: {
      ..._context,
      // Ø¥ØµÙ„Ø§Ø­ userAgent Ù„Ù„Ù€ SSR
      userAgent: (typeof window !== 'undefined' && _context?.userAgent) ||
                 (typeof navigator !== 'undefined' ? navigator.userAgent : 'SSR'),
      url: typeof window !== 'undefined' ? window.location.href : 'SSR',
      viewport: typeof window !== 'undefined' ? {
        width: window.innerWidth,
        height: window.innerHeight
      } : { width: 0, height: 0 }
    }
  }

  // ØªØ³Ø¬ÙŠÙ„ ÙÙŠ console Ù„Ù„ØªØ·ÙˆÙŠØ±
  if (process.env.NODE_ENV === 'development') {
    console.group('ğŸ”¥ Booking Error')
    logError('Error:', error)
    console.table(errorLog._context)
    console.groupEnd()
  }

  // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ù„Ù‰ logging service ÙÙŠ Ø§Ù„Ø¥Ù†ØªØ§Ø¬
  if (process.env.NODE_ENV === 'production') {
    // ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØ© Ø®Ø¯Ù…Ø© logging Ù‡Ù†Ø§ Ù…Ø«Ù„ Sentry Ø£Ùˆ LogRocket
    try {
      // Example: window.gtag?.('event', 'exception', { description: error.message })
    } catch (loggingError) {
      console.warn('Failed to log error to external service:', loggingError)
    }
  }
}

// Ø¥Ù†Ø´Ø§Ø¡ retry function Ù…Ø¹ backoff
export function createRetryWithBackoff<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  baseDelay: number = 1000,
  backoffMultiplier: number = 2
): (onRetry?: (attempt: number) => void) => Promise<T> {
  return async (onRetry?: (attempt: number) => void): Promise<T> => {
    let lastError: any

    for (let attempt = 1; attempt <= maxRetries + 1; attempt++) {
      try {
        return await fn()
      } catch (error) {
        lastError = error

        // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø£Ø®ÙŠØ±Ø©ØŒ Ø§Ø±ÙØ¹ Ø§Ù„Ø®Ø·Ø£
        if (attempt > maxRetries) {
          throw error
        }

        // ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥Ù…ÙƒØ§Ù†ÙŠØ© Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©
        const errorInfo = analyzeError(error)
        if (!errorInfo.canRetry) {
          throw error
        }

        // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ù‡Ù„Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ©
        const delay = errorInfo.retryAfter || (baseDelay * Math.pow(backoffMultiplier, attempt - 1))

        // Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„Ù…Ø³ØªØ¯Ø¹ÙŠ Ø¨Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©
        onRetry?.(attempt)

        // Ø§Ù†ØªØ¸Ø§Ø± Ù‚Ø¨Ù„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©
        await new Promise(resolve => setTimeout(resolve, delay))
      }
    }

    throw lastError
  }
}

// âœ… Ø¥Ø¶Ø§ÙØ© executeWithRetry Ø§Ù„Ù…ÙÙ‚ÙˆØ¯ - Ø¯Ø§Ù„Ø© Ø¨Ø³ÙŠØ·Ø©
export async function executeWithRetry<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  delay: number = 1000
): Promise<T> {
  let lastError: any

  for (let attempt = 1; attempt <= maxRetries + 1; attempt++) {
    try {
      return await fn()
    } catch (error) {
      lastError = error

      // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø£Ø®ÙŠØ±Ø©ØŒ Ø§Ø±ÙØ¹ Ø§Ù„Ø®Ø·Ø£
      if (attempt > maxRetries) {
        throw error
      }

      // ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥Ù…ÙƒØ§Ù†ÙŠØ© Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©
      const errorInfo = analyzeError(error)
      if (!errorInfo.canRetry) {
        throw error
      }

      // Ø§Ù†ØªØ¸Ø§Ø± Ù‚Ø¨Ù„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©
      await new Promise(resolve => setTimeout(resolve, delay))
    }
  }

  throw lastError
}

// âœ… Ø¥Ø¶Ø§ÙØ© createErrorToast Ø§Ù„Ù…ÙÙ‚ÙˆØ¯ - Ø¯Ø§Ù„Ø© Ø¨Ø³ÙŠØ·Ø©
export function createErrorToast(error: any, _context?: ErrorContext): {
  type: 'error'
  message: string
  duration: number
} {
  const errorInfo = analyzeError(error)
  
  return {
    type: 'error',
    message: errorInfo.arabicMessage,
    duration: 5000
  }
}

// âœ… Ø¥Ø¶Ø§ÙØ© handleServicesError Ø§Ù„Ù…ÙÙ‚ÙˆØ¯ - Ø¯Ø§Ù„Ø© Ø¨Ø³ÙŠØ·Ø©
export function handleServicesError(error: any): ErrorInfo {
  const errorInfo = analyzeError(error)
  
  // ØªØ³Ø¬ÙŠÙ„ Ø®Ø·Ø£ Ø§Ù„Ø®Ø¯Ù…Ø§Øª
  logBookingError(error, {
    timestamp: Date.now(),
    networkQuality: typeof navigator !== 'undefined' && !navigator.onLine ? 'offline' : 'fast'
  })

  return errorInfo
}

// Ø¥Ù†Ø´Ø§Ø¡ timeout wrapper
export function withTimeout<T>(
  promise: Promise<T>,
  timeoutMs: number = 10000,
  timeoutMessage: string = 'Request timeout'
): Promise<T> {
  return Promise.race([
    promise,
    new Promise<never>((_, reject) => {
      setTimeout(() => {
        reject(new Error(timeoutMessage))
      }, timeoutMs)
    })
  ])
}

// Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Error Boundary (Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙÙŠ Ù…ÙƒÙˆÙ†Ø§Øª tsx Ù…Ù†ÙØµÙ„Ø©)
export interface ErrorBoundaryState {
  hasError: boolean
  error?: Error
}

export interface ErrorBoundaryProps {
  children: React.ReactNode
  fallback?: (error: Error) => any
  onError?: (error: Error, errorInfo: any) => void
}

// Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ Error Boundary
export function createErrorBoundaryConfig(
  onError?: (error: Error, errorInfo: any) => void
) {
  return {
    getDerivedStateFromError: (error: Error): ErrorBoundaryState => {
      return { hasError: true, error }
    },

    componentDidCatch: (error: Error, errorInfo: any) => {
      logBookingError(error, {
        stackTrace: errorInfo.componentStack,
        timestamp: Date.now()
      })

      onError?.(error, errorInfo)
    }
  }
}

// Hook Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ ÙÙŠ Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª
export function useErrorHandler() {
  const handleError = (error: any, _context?: Partial<ErrorContext>) => {
    const errorInfo = handleBookingError(error, {
      timestamp: Date.now(),
      ..._context
    })

    return errorInfo
  }

  return { handleError }
}

// ØªØ­Ø¯ÙŠØ¯ Ø£ÙˆÙ„ÙˆÙŠØ© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
export function categorizeErrorSeverity(errorType: ErrorType): 'low' | 'medium' | 'high' | 'critical' {
  switch (errorType) {
    case ErrorType.NETWORK_ERROR:
    case ErrorType.TIMEOUT_ERROR:
      return 'medium'

    case ErrorType.VALIDATION_ERROR:
      return 'low'

    case ErrorType.BOOKING_CONFLICT:
      return 'high'

    case ErrorType.SERVER_ERROR:
    case ErrorType.RATE_LIMIT:
      return 'high'

    case ErrorType.UNKNOWN_ERROR:
      return 'critical'

    default:
      return 'medium'
  }
}

// Ø¥Ù†Ø´Ø§Ø¡ Ø±Ø³Ø§Ù„Ø© Ø®Ø·Ø£ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
export function createUserFriendlyErrorMessage(error: any, _context?: ErrorContext): string {
  const errorInfo = analyzeError(error)

  // Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø³ÙŠØ§Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…ÙÙŠØ¯Ø©
  let message = errorInfo.arabicMessage

  if (_context?.retryCount && _context.retryCount > 0) {
    message += ` (Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© ${_context.retryCount})`
  }

  if (errorInfo.suggestedAction) {
    message += `\nğŸ’¡ ${errorInfo.suggestedAction}`
  }

  return message
}